<dl class="dl-horizontal">
    <dt><span style="text-transform:capitalize" id="avg_coverage_type">Mean</span> coverage</dt>
    <dd><span id="avg_coverage"></span></dd>
</dl>
<div id="gene_plot">
    <span class="hidden-xs">
        <label for="display_coverage_metric_group">
            Display:
        </label>
        <span class="btn-group" data-toggle="buttons" id="display_coverage_metric_group">
            <button class="btn btn-primary active display_coverage_metric_buttons"
                    id="display_coverage_overview_button" data-tooltip="Shows all exons">
                <input type="radio">Overview</input>
            </button>
            <button class="btn btn-primary display_coverage_metric_buttons"
                    id="display_coverage_detail_button" data-tooltip="Zoomed in view (can scroll horizontally if needed)">
                <input type="radio">Detail</input>
            </button>
        </span>
        <label>
            <input type="checkbox" id="include_utrs_checkbox" value=""> Include UTRs in plot
        </label>
    </span>
    {% include 'coverage_selectors.html' %}
    <br/>
    <div id="gene_plot_container_container">
        <div id="loading_coverage">
            Loading coverage...
            <br/><br/>
        </div>
        <span id="gene_plot_axis_container" class="hidden-xs" style="width:50px; display: inline-block;"></span>
        <span id="gene_plot_container" style="overflow-x:scroll; display: inline-block;"></span>
        <a class="btn btn-success" id="coverage_plot_download" download="{{ plot_id }}_coverage">Save coverage plot</a>
        <a class="btn btn-success" id="exon_plot_download" download="{{ plot_id }}_exon">Save exon image</a>
    </div>
</div>
<div id="not_covered" style="display: none;">
    No coverage for this transcript.
</div>
<br/>
<script>
function create_coverage_chart() {
    // See change_coverage_chart(), which is very similar to this function.
    var scale_type = 'overview'; // These are the starting values.
    var metric = 'mean';
    var skip_utrs = true;

    var coords = skip_utrs ? 'pos_coding_noutr' : 'pos_coding';
    var coords_start = coords.replace('pos_', 'start_');
    var coords_end = coords.replace('pos_', 'end_');
    var coding_coordinate_params = get_coding_coordinate_params(skip_utrs);
    var chart_width;
    if (scale_type == 'overview') {
        chart_width = gene_chart_width;
    } else {
        chart_width = coding_coordinate_params.size*2;
    }
    var max_cov = 1;
    if (metric == 'mean' || metric == 'median') {
        max_cov = d3.max(window.coverage_stats, function(d) { return d[metric]; });
    }


    var exon_x_scale = d3.scale.linear()
        .domain([0, coding_coordinate_params.size])
        .range([0, chart_width]);

    var y = d3.scale.linear()
        .domain([0, max_cov])
        .range([gene_chart_height, 0]);

    var yAxis = d3.svg.axis()
        .scale(y)
        .orient("left");

    var svg = d3.select('#gene_plot_container').append("svg")
        .attr("width", chart_width + gene_chart_margin.left + gene_chart_margin.right)
        .attr("height", gene_chart_height + gene_chart_margin.top + gene_chart_margin.bottom)
        .attr('id', 'inner_svg')
        .attr('class', 'hidden-xs')
        .append("g")
        .attr('id', 'inner_graph')
        .attr("transform", "translate(" + gene_chart_margin.left + "," + gene_chart_margin.top + ")");

    var area = d3.svg.area()
        .x( function(d) {
            return exon_x_scale(d['pos']);
        }).y0( function(d) {
            return gene_chart_height;
        }).y1( function(d) {
            return (metric in d) ? y(d[metric]) : gene_chart_height;
        });

    //This is a hack, revealing that the surrounding code needs changes.
    my_datum = [];
    _.each(window.coverage_stats, function(d) {
        if (d[coords_start] && d[coords_end]) {
            var o = [{}, {}, {}, {}];
            o[0]['pos'] = o[1]['pos'] = d[coords_start];
            o[2]['pos'] = o[3]['pos'] = 1 + d[coords_end];
            o[1][metric] = o[2][metric] = d[metric] || 0;
            o[0][metric] = o[3][metric] = 0;
            my_datum.push.apply(my_datum, o); //concatenate o to my_datum
        }
    });

    svg.append("path")
        .datum(my_datum)
        .style("fill", "steelblue")
        .attr('class', 'area')
        .attr("d", area);

    svg.append("g")
        .attr("class", "y axis")
        .call(yAxis);

    d3.select('#gene_plot_container').append("br"); //make sure track_svg is below graph and not to the right of it

    // plot exons
    var svg_outer = d3.select('#gene_plot_container').append("svg")
        .attr("width", chart_width + gene_chart_margin_lower.left + gene_chart_margin_lower.right)
        .attr("height", lower_gene_chart_height)
        .attr('id', 'track_svg')
        .append("g")
        .attr('id', 'track')
        .attr("transform", "translate(" + gene_chart_margin_lower.left + "," + 0 + ")");

    var exon_color = "lightsteelblue";
    svg_outer.selectAll("line.padded_exon")
        .data(window.transcript.exons)
        .enter()
        .append('line')
        .attr("class", "padded_exon")
        .attr("y1", lower_gene_chart_height/2)
        .attr("y2", lower_gene_chart_height/2)
        .attr("x1", function(d) { return exon_x_scale(get_coding_coordinate(d.start - EXON_PADDING, skip_utrs)); })
        .attr("x2", function(d) { return exon_x_scale(get_coding_coordinate(d.stop + EXON_PADDING, skip_utrs)); })
        .style("visibility", function(d) {
            // TODO: check that x1 and x2 turned out okay.
            if (d.feature_type === "CDS" || !skip_utrs) {
                return "visible";
            } else {
                return "hidden";
            }
        })
        .attr("stroke-width", 5)
        .attr("stroke", exon_color);

    // plot exon rects
    svg_outer.selectAll(".track_bar")
        .data(window.transcript.exons)
        .enter()
        .append("rect")
        .attr('class', 'track_bar')
        .style("fill", exon_color)
        .attr("x", function(d, i) { return exon_x_scale(get_coding_coordinate(d.start, skip_utrs)); })
        .attr("y", function(d, i) {
            if (d.feature_type == 'CDS') {
                return 0;
            } else {
                return lower_gene_chart_height/4;
            }
        })
        .attr("width", function(d, i) {
            // TODO: use precalc_coding_coordinates_for_bins() to constrain these to exons
            if (get_coding_coordinate(d.start, skip_utrs) === null) {
                return exon_x_scale(0);
            }
            return exon_x_scale(d.stop-d.start+1);
        })
        .attr("height", function(d, i) {
            if (d.feature_type == 'CDS') {
                return lower_gene_chart_height;
            } else {
                return lower_gene_chart_height/2;
            }
        });


    var a_s = window.transcript.strand == "-"? -1 : 1; //arrow direction
    var a_x = -5;  //arrow position on x-axis
    var a_y = lower_gene_chart_height/2.0; //arrow position on y-axis
    var a_w = 2; //arrow width
    var points = [[a_x+a_s*6, a_y], [a_x+a_s*1, a_y+a_w*3], [a_x+a_s*1, a_y+a_w], [a_x-a_s*9, a_y+a_w],
        [a_x-a_s*9, a_y-a_w], [a_x+a_s*1, a_y-a_w], [a_x+a_s*1, a_y-a_w*3]];
    svg_outer.append("polygon")
            .attr("points", points.join(" "))
            .attr("fill", "steelblue")
            .attr("stroke", "black");

    // show variant category on hover
    window.variant_plot_tip = d3.tip().attr('class', 'd3-tip').html(function(d) {
        if (d.category) {
            var csq = d.major_consequence.replace('_variant', '')
                    .replace('_', ' ')
                    .replace('utr', 'UTR')
                    .replace('3 prime', "3'")
                    .replace('5 prime', "5'")
                    .replace('nc ', "non-coding ");
            var output = csq + '<br/>' + d.chrom + ':' + d.pos + ' ' + d.ref + '&#8594;' + d.alt;
            if (d.major_consequence == 'missense_variant' || d.major_consequence == 'synonymous_variant') {
                output += '<br/>' + d.HGVSp;
            }
            output += '<br/>Frequency: ' + d.allele_freq.toPrecision(3);
            output += '<br/>Pos: ' + d.pos;
            return output;
        } else {
            return 'None';
        }
    });
    svg.call(window.variant_plot_tip);

    create_variants_plot(svg_outer, exon_x_scale, coords);
}

function create_variants_plot(svg_outer, exon_x_scale, coords) {
    var bounds = get_af_bounds(window.variants_in_transcript);
    var min_af = bounds[0];
    var max_af = bounds[1];
    var variant_size_scale = d3.scale.log()
        .domain([min_af, max_af])
        .range([2, lower_gene_chart_height/3]);

    svg_outer.selectAll('a.track_variant_link') //Somehow, adding the right selector magically fixed everything.
        .data(window.variants_in_transcript) //, function(d) {return d.variant_id;})
        .enter()
        .append("a")
        .attr('class', 'track_variant_link')
        .attr("xlink:href", function(d, i) { return "/variant/" + d.chrom + "-" + d.pos + "-" + d.ref + "-" + d.alt; })
        .attr("data-toggle", "tooltip")
        .attr('category', function(d) {
            return d.category;
        })
        .attr('variant_id', function(d) {
            return d.variant_id;
        })
        .on('mouseover', function(d) {
            $('#variant_' + d.variant_id).find('td').addClass('table_hover');
            window.variant_plot_tip.show(d);
        })
        .on('mouseout', function(d) {
            $('#variant_' + d.variant_id).find('td').removeClass('table_hover');
            window.variant_plot_tip.hide(d);
        })
        .append("ellipse")
        .attr("class", function(d) {
            return "track_variant " + d.category;
        })
        .style("opacity", 0.5)
        .style("visibility", function(d) {
            return (d[coords] == undefined) ? "hidden" : "visible";
        })
        .attr("cx",  function(d) {
            if (d[coords] == undefined) {
                // TODO: put these at the correct position, but hide them.
                return -100;
            } else {
                return exon_x_scale(d[coords]);
            }
        })
        .attr("cy", lower_gene_chart_height/2)
        .attr("rx", 2)
        .attr("ry", function(d, i) {
            if (!d.allele_freq) {
                return 0;
            } else {
                return variant_size_scale(d.allele_freq);
            }
        })
        // Workaround for exporting d3 to SVG (other delcaration in style.css).
        .attr('stroke', variant_colors)
        .attr('fill', variant_colors);
}

function add_variants_to_variants_plot() {
    var svg_outer = d3.select('#gene_plot_container').select('#track');
    var skip_utrs = ! $('#include_utrs_checkbox').is(':checked');
    var coding_coordinate_params = get_coding_coordinate_params(skip_utrs);
    var scale_type = $('.display_coverage_metric_buttons.active').attr('id').replace('display_coverage_', '').replace('_button', '');
    var chart_width;
    if (scale_type == 'overview') {
        chart_width = gene_chart_width;
    } else {
        chart_width = coding_coordinate_params.size*2;
    }
    var exon_x_scale = d3.scale.linear()
        .domain([0, coding_coordinate_params.size])
        .range([0, chart_width]);
    var coords = skip_utrs ? 'pos_coding_noutr' : 'pos_coding';

    create_variants_plot(svg_outer, exon_x_scale, coords);
}

function variant_colors(d) {
    if (d.category == 'lof_variant') {
        return '#cd2932';
    } else if (d.category == 'missense_variant') {
        return '#a96500';
    } else if (d.category == 'synonymous_variant') {
        return '#157e28';
    }
}

function change_coverage_chart(scale_type, metric, skip_utrs) {
    // See create_coverage_chart(), which is very similar to this function.
    //scale_type is either "detail" or "overview" (or someday "linear_overview")
    //metric is one of "mean", "median", "1", "5", "10", ... "50", "100"
    //skip_utrs is boolean

    var coords = skip_utrs ? 'pos_coding_noutr' : 'pos_coding';
    var coords_start = coords.replace('pos_', 'start_');
    var coords_end = coords.replace('pos_', 'end_');
    var coding_coordinate_params = get_coding_coordinate_params(skip_utrs);
    var chart_width;
    if (scale_type == 'overview') {
        chart_width = gene_chart_width;
    } else {
        chart_width = coding_coordinate_params.size*2;
    }
    var max_cov = 1;
    if (metric == 'mean' || metric == 'median') {
        max_cov = d3.max(window.coverage_stats, function(d) { return d[metric]; });
    }

    var exon_x_scale = d3.scale.linear()
        .domain([0, coding_coordinate_params.size])
        .range([0, chart_width]);

    var svg = d3.select('#gene_plot_container').select('#inner_svg')
        .attr("width", chart_width + gene_chart_margin.left + gene_chart_margin.right)
        .attr("height", gene_chart_height + gene_chart_margin.top + gene_chart_margin.bottom)
        .select('#inner_graph');

    var y = d3.scale.linear()
        .domain([0, max_cov])
        .range([gene_chart_height, 0]);

    var area = d3.svg.area()
        .x( function(d) { // Is .x() necessary?
            return exon_x_scale(d['pos']);
        }).y0( function(d) {
            return gene_chart_height;
        }).y1( function(d) {
            return (metric in d) ? y(d[metric]) : gene_chart_height;
        });

    //This is a hack, revealing that the surrounding code needs changes.
    var my_datum = [];
    _.each(window.coverage_stats, function(d) {
        if (d[coords_start] && d[coords_end]) {
            var o = [{}, {}, {}, {}];
            o[0]['pos'] = o[1]['pos'] = d[coords_start];
            o[2]['pos'] = o[3]['pos'] = 1 + d[coords_end];
            o[1][metric] = o[2][metric] = d[metric] || 0;
            o[0][metric] = o[3][metric] = 0;
            my_datum.push.apply(my_datum, o); //concatenate o to my_datum
        }
    });

    var path = svg.selectAll("path")
        .datum(my_datum)
        .transition()
        .duration(500)
        .attr("d", area)
        .style("fill", "steelblue")
        .attr('class', 'area');

    // plot exons
    var svg_outer = d3.select('#gene_plot_container').select('#track_svg')
        .attr("width", chart_width + gene_chart_margin_lower.left + gene_chart_margin_lower.right)
        .attr("height", lower_gene_chart_height).select('#track');

    var exon_color = "lightsteelblue";
    svg_outer.selectAll("line.padded_exon")
        .data(window.transcript.exons)
        .transition()
        .duration(500)
        .attr("class", "padded_exon")
        .attr("y1", lower_gene_chart_height/2)
        .attr("y2", lower_gene_chart_height/2)
        .attr("x1", function(d) { return exon_x_scale(get_coding_coordinate(d.start - EXON_PADDING, skip_utrs)); })
        .attr("x2", function(d) { return exon_x_scale(get_coding_coordinate(d.stop + EXON_PADDING, skip_utrs)); })
        .style("visibility", function(d) {
            if (d.feature_type === "CDS" || !skip_utrs)
                return "visible";
            else
                return "hidden";
        })
        .attr("stroke-width", 5)
        .attr("stroke", exon_color);

    // plot exon rounded rects
    svg_outer.selectAll("rect")
        .data(window.transcript.exons)
        .transition()
        .duration(500)
        .attr("x", function(d, i) { return exon_x_scale(get_coding_coordinate(d.start, skip_utrs)); })
        .attr("width", function(d, i) {
            // TODO: use precalc_coding_coordinates_for_bins() to constrain these to exons
            if (get_coding_coordinate(d.start, skip_utrs) === null) {
                return exon_x_scale(0);
            }
            return exon_x_scale(d.stop-d.start+1);
        });

    // plot variants
    svg_outer.selectAll("a.track_variant_link")
        .data(window.variants_in_transcript)
        .transition()
        .duration(500)
        .selectAll('ellipse')
        .style("visibility", function(d) {
            return (d[coords] == undefined) ? "hidden" : "visible";
        })
        .attr("cx", function(d) {
            if (d[coords] == undefined) {
                // TODO: put these at the correct position, but hide them.
                return -100;
            } else {
                return exon_x_scale(d[coords]);
            }
        });

    var yAxis = d3.svg.axis()
        .scale(y)
        .orient("left");

    svg.select(".y.axis")
        .transition()
        .duration(200)
        .call(yAxis);
}

function change_coverage_chart_with_values_from_page() {
    // Note: if this function runs immediately after a button is pressed, Bootstrap might not have toggled '.active' yet, so the results will be bad. Use setTimeout(..., 0)
    var skip_utrs = ! $('#include_utrs_checkbox').is(':checked');
    var scale_type = $('.display_coverage_metric_buttons.active').attr('id').replace('display_coverage_', '').replace('_button', '');
    var metric;
    if ($('.coverage_metric_buttons.active').attr('id') === 'covered_covmet_button') {
        metric = $('#over_x_select').val().replace('X', '');
    } else {
        metric = $("#average_select").val();
    }
    change_coverage_chart(scale_type, metric, skip_utrs);
}

function coverage_sum(key) {
    var total = 0;
    $.map(window.coverage_stats, function(entry) {
        total += entry[key];
    });
    return (total/window.coverage_stats.length).toPrecision(4);
}

$(document).ready(function() {
    build_the_graph();
    $("#coverage_plot_download").on('click', function() {
        download(set_plot_image('gene_plot_container', 0), $(this).attr('download'));
    });
    $("#exon_plot_download").on('click', function() {
        download(set_plot_image('gene_plot_container', 1), $(this).attr('download'));
    });
});

function download(data_uri, filename) {
    //This works in Chrome and Firefox and probably IE but not Safari.
    var link = document.createElement("a");
    link.download = filename;
    link.href = data_uri;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    delete link;
}

function build_the_graph () {
    if ($(window).width() < 768) {
        $('#gene_plot_container').css('width', $(window).width() + "px");
    } else {
        $('#gene_plot_container').css('width', $(window).width()*10/12 + "px");
    }
    precalc_coding_coordinates_for_bins(window.coverage_stats); //Note: This modifies window.coverage_stats
    precalc_coding_coordinates(window.variants_in_transcript); //Likewise for window.variants_in_transcript

    // only show variants that have a coding coordinate
    window.variants_in_transcript = _.filter(window.variants_in_transcript, function(variant) {
        return variant.pos_coding != undefined;
    });

    // only show coding rects that have a coding coordinate
    window.coverage_stats = _.filter(window.coverage_stats, function(d) {
        return d.start !== undefined && d.end !== undefined;
    });
    $('#avg_coverage').html(coverage_sum('mean'));
    $('#avg_coverage_x').html(coverage_sum('30')*100 + '%');

    if (window.coverage_stats != null) {
        create_coverage_chart();
        if (window.variants_in_transcript.length) {
            update_variants();
        }
        $('#loading_coverage').hide();
    } else {
        $('#gene_plot').hide();
        $('#not_covered').show();
    }

    // Listen for changes to the coverage plot
    $('.coverage_metric_buttons').change(function () {
        $('.coverage_subcat_selectors').hide();
        if ($(this).attr('id') === 'covered_covmet_button') {
            $('#over_x_select_container').show();
        } else {
            $('#average_select_container').show();
        }
        setTimeout(change_coverage_chart_with_values_from_page, 0);
    });
    $('#average_select').change(function () {
        $('#avg_coverage_type').html($(this).val());
        $('#avg_coverage').html(coverage_sum($(this).val()));
        setTimeout(change_coverage_chart_with_values_from_page, 0);
    });
    $('#over_x_select, #include_utrs_checkbox, .display_coverage_metric_buttons').change(function () {
        setTimeout(change_coverage_chart_with_values_from_page, 0);
    });

    // Change exon diagram
    $('#inverted_checkbox').change(function () {
        setTimeout(function () {
            var v = $('#inverted_checkbox').is(':checked');
            change_track_chart_variant_size(window.variants_in_transcript, v, '#gene_plot_container');
        }, 0);
    });
}
</script>
